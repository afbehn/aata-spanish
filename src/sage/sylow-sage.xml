<?xml version="1.0" encoding="UTF-8" ?>

<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->

<section xml:id="sylow-sage">
	<title>Sage</title>

	<subsection>
		<title>Subgrupos de Sylow</title>

		<p>El método <c>.sylow_subgroup(p)</c>, implementaado para grupos de permutaciones, entregará un <m>p</m>-subgrupo de Sylow.  Si el primo no es un divisor propio del orden del grupo devuelve un subgrupo de orden <m>p^0</m>, en otras palabras, el subgrupo trivial.    A veces, solo necesitaremos <em>un</em> subgrupo de Sylow, pues cualquiera dos <m>p</m>-subgrupos de Sylow son conjugados, y por ende isomorfos (Teorema<nbsp /><xref ref="theorem-second-sylow" />).  Esto también quiere decir que podemos crear otros <m>p</m>-subgrupos de Sylow conjugando el que obtuvimos.  El método <c>.conjugate(g)</c> conjugará el grupo por <c>g</c>.</p>

		<p>Mediante conjugaciones de un solo <m>p</m>-subgrupo de Sylow <m>p</m>, siempre obtendremos subgrupos repetidos.  Necesitamos una construcción un poco más complicada para formar una lista que contenga cada <m>p</m>-subgrupo de Sylow exactamente una vez.  La siguiente rutina que calcula todos los <m>p</m>-subgrupos de Sylow será útil para lo que queda de esta sección.  Se podría hacer más eficiente conjugando solo por un elemento de cada clase lateral del normalizador, pero es suficiente para nuestros propósitos acá.  Asegúrese de ejecutar la próxima celda, para poder usar la función más adelante.</p>

        <sage>
            <input>
            def all_sylow(G, p):
                '''Form the set of all distinct Sylow p-subgroups of G'''
                scriptP = []
                P = G.sylow_subgroup(p)
                for x in G:
                    H = P.conjugate(x)
                    if not(H in scriptP):
                        scriptP.append(H)
                return scriptP
            </input>
        </sage>

		<p>Investiguemos los subgrupos de Sylow del grupo dihedral <m>D_{18}</m>.  Como grupo de orden <m>36=2^2\cdot 3^2</m>, sabemos por el Primer Teorema de Sylow que tiene un <m>2</m>-subgrupo de orden <m>4</m> y un <m>3</m>-subgrupo de Sylow de orden <m>9</m>.  Comenzando con <m>p=2</m>, obtenemos un <m>2</m>-subgrupo de Sylow, formamos todos sus conjugados, y formamos una lista de los subgrupos sin repeticiones. </p>

		<sage>
		<input>
		G = DihedralGroup(18)
		S2 = G.sylow_subgroup(2); S2
		</input>
		<output>
		Subgroup of (Dihedral group of order 36 as a permutation group)
		generated by
		[(2,18)(3,17)(4,16)(5,15)(6,14)(7,13)(8,12)(9,11),
		(1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18)]
		</output>
		</sage>

		<sage>
			<input>
			uniqS2 = all_sylow(G, 2)
			uniqS2
			</input>
            <output>
            [Permutation Group with generators
             [(2,18)(3,17)(4,16)(5,15)(6,14)(7,13)(8,12)(9,11),
             (1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18)],
             Permutation Group with generators
             [(1,3)(4,18)(5,17)(6,16)(7,15)(8,14)(9,13)(10,12),
             (1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18)],
             Permutation Group with generators
             [(1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18),
             (1,17)(2,16)(3,15)(4,14)(5,13)(6,12)(7,11)(8,10)],
             Permutation Group with generators
             [(1,5)(2,4)(6,18)(7,17)(8,16)(9,15)(10,14)(11,13),
             (1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18)],
             Permutation Group with generators
             [(1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18),
             (1,15)(2,14)(3,13)(4,12)(5,11)(6,10)(7,9)(16,18)],
             Permutation Group with generators
             [(1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18),
             (1,13)(2,12)(3,11)(4,10)(5,9)(6,8)(14,18)(15,17)],
             Permutation Group with generators
             [(1,7)(2,6)(3,5)(8,18)(9,17)(10,16)(11,15)(12,14),
             (1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18)],
             Permutation Group with generators
             [(1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18),
             (1,11)(2,10)(3,9)(4,8)(5,7)(12,18)(13,17)(14,16)],
             Permutation Group with generators
             [(1,9)(2,8)(3,7)(4,6)(10,18)(11,17)(12,16)(13,15),
             (1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18)]]
            </output>
		</sage>

		<sage>
			<input>
			len(uniqS2)
			</input>
			<output>9</output>
		</sage>

		<p>El Tercer Teorema de Sylow nos  dice que para <m>p=2</m> podríamos tener <m>1, 3</m> o <m>9</m> <m>2</m>-subgrupos de Sylow, de manera que los <m>9</m> subgrupos obtenidos son consistentes con lo que predice la teoría.  ¿Puede visualizar cada uno de estos subgrupos como simetrías de un polígono regular de <m>18</m> lados?  Notemos que también tenemos muchos subgrupos de orden <m>2</m> dentro de estos subgrupos de orden <m>4</m>.</p>

		<p>Ahora para <m>p=3</m>.</p>

		<sage>
		<input>
		G = DihedralGroup(18)
		S3 = G.sylow_subgroup(3); S3
		</input>
		<output>
		Subgroup of (Dihedral group of order 36 as a permutation group)
		generated by
		[(1,7,13)(2,8,14)(3,9,15)(4,10,16)(5,11,17)(6,12,18),
		(1,15,11,7,3,17,13,9,5)(2,16,12,8,4,18,14,10,6)]
		</output>
		</sage>

		<sage>
			<input>
			uniqS3 = all_sylow(G, 3)
			uniqS3
			</input>
			<output>
			[Permutation Group with generators
			[(1,7,13)(2,8,14)(3,9,15)(4,10,16)(5,11,17)(6,12,18),
			(1,15,11,7,3,17,13,9,5)(2,16,12,8,4,18,14,10,6)]]
			</output>
		</sage>

		<sage>
			<input>
			len(uniqS3)
			</input>
			<output>1</output>
		</sage>

		<p>¿Qué es lo que predice el Tercer Teorema de Sylow?  Habiendo encontrado solo un subgrupo de Sylow computacionalmente, sabemos que todos los conjugados de este único <m>3</m>-subgrupo de Sylow son iguales.  En otras palabras el <m>3</m>-subgrupo de Sylow es normal en <m>D_{18}</m>.  Comprobémoslo de todas formas.</p>

		<sage>
		<input>
		S3.is_normal(G)
		</input>
		<output>
		True
		</output>
		</sage>

		<p>Al menos uno de los subgrupos de orden <m>3</m> contenidos en este <m>3</m>-subgrupo de Sylow debiese ser obvio mirando los órdenes de los generadores, y luego podríamos incluso darnos cuenta que los generadores dados se pueden reducir, y uno es una potencia del otro.</p>

		<sage>
		<input>
		S3.is_cyclic()
		</input>
		<output>
		True
		</output>
		</sage>

		<p>Recuerde que existen muchos otros subgrupos, de otros órdenes.  Por ejemplo, ¿puede construir un subgrupo de oreden <m>6=2\cdot 3</m> en <m>D_{18}</m>?</p>

		</subsection>

		<subsection>
		<title>Normalizadores</title>

		<p>Un comando nuevo que resulta relevante para esta sección es la construcción del normalizador.   El comando <c>G.normalizer(H)</c> devolverá el subgrupo de <c>G</c> que contiene todos los elementos que normalizan al subgrupo <c>H</c>.  Ilustraremos su uso con los subgrupos de Sylow de arriba.</p>

		<sage>
		<input>
		G = DihedralGroup(18)
		S2 = G.sylow_subgroup(2)
		S3 = G.sylow_subgroup(3)
		N2 = G.normalizer(S2); N2
		</input>
		<output>
		Subgroup of (Dihedral group of order 36 as a permutation group)
		generated by
		[(2,18)(3,17)(4,16)(5,15)(6,14)(7,13)(8,12)(9,11),
		(1,10)(2,11)(3,12)(4,13)(5,14)(6,15)(7,16)(8,17)(9,18)]
		</output>
		</sage>

		<sage>
		<input>
		N2 == S2
		</input>
		<output>
		True
		</output>
		</sage>

		<sage>
		<input>
		N3 = G.normalizer(S3); N3
		</input>
		<output>
		Subgroup of (Dihedral group of order 36 as a permutation group)
		generated by
		[(2,18)(3,17)(4,16)(5,15)(6,14)(7,13)(8,12)(9,11),
		(1,2)(3,18)(4,17)(5,16)(6,15)(7,14)(8,13)(9,12)(10,11),
		(1,7,13)(2,8,14)(3,9,15)(4,10,16)(5,11,17)(6,12,18),
		(1,15,11,7,3,17,13,9,5)(2,16,12,8,4,18,14,10,6)]
		</output>
		</sage>

		<sage>
		<input>
		N3 == G
		</input>
		<output>
		True
		</output>
		</sage>

		<p>El normalizador de un subgrupo siempre contiene al subgrupo, de manera que el normalizador de <c>S2</c> este todo lo pequeño que puede ser.  Ya sabíamos que <c>S3</c> es normal en <c>G</c>, así es que no es sorprendente que su normalizador sea todo lo grande que puede ser <mdash /> todo elemento de <c>G</c> normaliza a <c>S3</c>.  Calculemos un normalizador más <q>interesante</q> en <m>D_{18}</m></p>

		<sage>
		<input>
		G = DihedralGroup(18)
		a = G("(1,7,13)(2,8,14)(3,9,15)(4,10,16)(5,11,17)(6,12,18)")
		b = G("(1,5)(2,4)(6,18)(7,17)(8,16)(9,15)(10,14)(11,13)")
		H = G.subgroup([a, b])
		H.order()
		</input>
		<output>
		6
		</output>
		</sage>

		<sage>
		<input>
		N = G.normalizer(H)
		N
		</input>
		<output>
		Subgroup of (Dihedral group of order 36 as a permutation group)
		generated by
		[(1,2)(3,18)(4,17)(5,16)(6,15)(7,14)(8,13)(9,12)(10,11),
		(1,5)(2,4)(6,18)(7,17)(8,16)(9,15)(10,14)(11,13),
		(1,13,7)(2,14,8)(3,15,9)(4,16,10)(5,17,11)(6,18,12)]
		</output>
		</sage>

		<sage>
		<input>
		N.order()
		</input>
		<output>
		12
		</output>
		</sage>

		<p>Para este subgrupo de orden <m>6</m>, el normalizador es estrictamente más grande que el subgrupo, pero estrictamente menor que el grupo completo (y por ende no es normal en el grupo dihedral).  Trivialmente, un subgrupo es normal en su normalizador:</p>

		<sage>
		<input>
		H.is_normal(G)
		</input>
		<output>
		False
		</output>
		</sage>

		<sage>
		<input>
		H.is_normal(N)
		</input>
		<output>
		True
		</output>
		</sage>

	</subsection>

	<subsection>
		<title>Grupos Finitos Simples</title>

		<p>Ya vimos el método <c>.is_simple()</c>.  En el Ejemplo<nbsp /><xref ref="example-group-pn" /> que un grupo de orden <m>64</m> nunca es simple.  El grupo dicíclico <c>DiCyclicGroup(16)</c> es un grupo no-abeliano de orden <m>64</m>, así es que podemos poner a prueba el método con este grupo.  Resulta que este grupo tiene muchos subgrupos normales <mdash /> la lista siempre contendrá al grupo trivial y al grupo completo, así cualquier número mayor a <m>2</m> indica un subgrupo normal no-trivial.</p>

		<sage>
		<input>
		DC=DiCyclicGroup(16)
		DC.order()
		</input>
		<output>
		64
		</output>
		</sage>

		<sage>
		<input>
		DC.is_simple()
		</input>
		<output>
		False
		</output>
		</sage>

		<sage>
		<input>
		ns = DC.normal_subgroups()
		len(ns)
		</input>
		<output>
		9
		</output>
		</sage>

		<p>Acá viene un grupo bastante interesante, uno de los <m>26</m> grupos simples esporádicos, conocido como el grupo de Higman-Sims, <m>HS</m>.  Los generadores usados abajo vienen de su representación permutacional en 100 puntos en formato <acro>GAP</acro>, disponible en <url href="http://web.mat.bham.ac.uk/atlas/v2.0/spor/HS/">web.mat.bham.ac.uk/atlas/v2.0/spor/HS/</url>.  Dos generadores, uno de orden <m>2</m> y otro de orden <m>5</m> (como se puede ver fácilmente), generando <m>44\,352\,000</m> elementos, pero ningún subgrupo normal.  Impresionante.</p>

		<sage>
		<input>
		G = SymmetricGroup(100)
		a = G([(1,60),  (2,72),  (3,81),  (4,43),  (5,11),  (6,87),
		        (7,34),  (9,63),  (12,46), (13,28), (14,71), (15,42),
		        (16,97), (18,57), (19,52), (21,32), (23,47), (24,54),
		        (25,83), (26,78), (29,89), (30,39), (33,61), (35,56),
		        (37,67), (44,76), (45,88), (48,59), (49,86), (50,74),
		        (51,66), (53,99), (55,75), (62,73), (65,79), (68,82),
		        (77,92), (84,90), (85,98), (94,100)])
		b = G([(1,86,13,10,47),  (2,53,30,8,38),
		        (3,40,48,25,17),  (4,29,92,88,43),   (5,98,66,54, 65),
		        (6,27,51,73,24),  (7,83,16,20,28),   (9,23,89,95,61),
		        (11,42,46,91,32), (12,14, 81,55,68), (15,90,31,56,37),
		        (18,69,45,84,76), (19,59,79,35,93),  (21,22,64,39,100),
		        (26,58,96,85,77), (33,52,94,75,44),  (34,62,87,78,50),
		        (36,82,60,74,72), (41,80,70,49,67),  (57,63,71,99,97)])
		a.order(), b.order()
		</input>
		<output>
		(2, 5)
		</output>
		</sage>

		<sage>
		<input>
		HS = G.subgroup([a, b])
		HS.order()
		</input>
		<output>
		44352000
		</output>
		</sage>

		<sage>
		<input>
		HS.is_simple()
		</input>
		<output>
		True
		</output>
		</sage>

		<p>Vimos antes este grupo en los Ejercicios del Capítulo<nbsp /><xref ref="actions" /> sobre acciones de grupo, donde era el único subgrupo normal no trivial del grupo de automorfismos del grafo de Higman-Sims, de ahí su nombre.</p>

	</subsection>

	<subsection>
		<title>Consola e Interfaz <acro>GAP</acro></title>

		<p>Acá concluimos el estudio exclusivo de teoría de grupos, aunque seguiremos usando algunos grupos en las secciones que siguientes.  Como ya hemos destacado, mucho del lo que hace Sage con grupos es realizado por el programa de código aberto, <q>Groups, Algorithms, and Programming,</q> más conocido como <acro>GAP</acro>.  Si luego de este curso, sus necesidades superan la capacidad de Sage en relación a grupos, entonces aprender <acro>GAP</acro> sería el próximo paso como teórico de grupos. Cada copia de Sage incluye una copia de <acro>GAP</acro> y se puede saber fácilmente cuál es la versión de <acro>GAP</acro> incluida:</p>

		<sage>
		<input>gap.version()</input>
		<output>'4.8.6'</output>
		</sage>

		<p>En Sage se puede interactuar con <acro>GAP</acro> de diferentes formas. La más directa es creando un grupo de permutaciones por medio del comando <c>gap()</c> de Sage.</p>

		<sage>
		<input>
		G = gap('Group( (1,2,3,4,5,6), (1,3,5) )')
		G
		</input>
		<output>
		Group( [ (1,2,3,4,5,6), (1,3,5) ] )
		</output>
		</sage>

		<p>Ahora podemos usar casi cualquier comando <acro>GAP</acro> con <c>G</c>, vía la convención de que la mayoría de los comandos en  <acro>GAP</acro> esperan recibir un grupo como su primer argumento, y en su lugar proveemos el grupo usando la sintaxis orientada al objeto <c>G.</c>.  Si consulta un manual de <acro>GAP</acro> verá que <c>Center</c> es un comando <acro>GAP</acro> que toma un grupo como su único argumento, y <c>Centralizer</c> es un comando <acro>GAP</acro> que requiere dos argumentos <mdash /> un grupo y luego un elemento del grupo.</p>

		<sage>
		<input>
		G.Center()
		</input>
		<output>
		Group( [ ( 1, 3, 5)( 2, 4, 6) ] )
		</output>
		</sage>

		<sage>
		<input>
		G.Centralizer('(1, 3, 5)')
		</input>
		<output>
		Group( [ (1,3,5), (2,4,6), (1,3,5)(2,4,6) ] )
		</output>
		</sage>

		<p>Si usa la interfaz Notebook de Sage puede poner <c>%gap</c> en la primera línea de una celda y la celda completa se interpretará como si estuviera interactuando directamente con <acro>GAP</acro>.  Esto significa que ahora puede (y debe) usar la sintaxis de <acro>GAP</acro>, que como puede ver arriba, es ligeramente diferente a la sintaxis de Sage.  También se puede usar el menú en el comienzo de la página para seleccionar <c>gap</c> en lugar de <c>sage</c> y la hoja de trabajo completa será interpretada como <acro>GAP</acro>.  Acá un ejemplo simple, que debiera poder ejecutar en su hoja de trabajo actual.  Este ejemplo particular no correrá bien en una celda Sage en la versión web de esta sección.</p>

		<sage type="display">
		<input>
		%gap
		G := Group( (1,2,3,4,5,6), (1,3,5) );
		Centralizer(G, (1,3,5));
		</input>
		</sage>

		<p>Notemos que<ul>
			<li><p>No es necesario encerrar las permutaciones individuales con tantas cremillas como haríamos en Sage.</p></li>

			<li><p>La asignación es <c>:=</c> no <c>=</c>.  Si olvida los dos puntos, obtendrá un error del tipo <c>Variable: 'G' must have a value</c></p></li>

			<li><p>Una línea <em>debe</em> terminar en punto y coma (;).  Si olvida el punto y coma al final la línea, las líneas se fusionarán como si fuera una sola.</p></li>
		</ul></p>

		<p>Puede obtener ayuda acerca de los comandos en <acro>GAP</acro> como se muestra más abajo, pero pronto se dará cuenta que <acro>GAP</acro> supone que usted sabe más álgebra de lo que supone Sage.</p>

		<sage doctest="not tested">
		<input>
		print(gap.help('SymmetricGroup', pager=False))
		</input>
		</sage>

		<p>En la versión de línea de comando de Sage, también es posible usar la <q>consola</q> <acro>GAP</acro>.   Nuevamente, será necesario usar la sintaxis de <acro>GAP</acro>, y no tendrá muchas de las comodidades del Notebook Sage.  También es bueno saber de antemano que <c>quit;</c> es la forma de salir de la consola <acro>GAP</acro> y volver a Sage.  Si corre Sage en la línea de comando, use el comando <c>gap_console()</c> para iniciar <acro>GAP</acro>.</p>

		<p>Es reconfortante saber que con Sage tenemos una copia completa de <acro>GAP</acro>, instalada y lista para correr.  Pero, este no es un tutorial de <acro>GAP</acro>, así es que si le interesa, puede consultar la página oficial de <acro>GAP</acro>: <url href="http://www.gap-system.org">www.gap-system.org</url> para aprender más sobre <acro>GAP</acro>.</p>

	</subsection>

</section>
