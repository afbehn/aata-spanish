<?xml version="1.0"?>
<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->
<!--                                               -->
<!-- This file is automatically generated from the -->
<!-- private solution manual.  Minor contributed   -->
<!-- edits can be made against this file for       -->
<!-- the purpose of a pull request.                -->
<exercises xml:id="cosets-sage-exercises">
	<title>Ejercicios en Sage</title>

	<introduction>
		<p>Los siguientes ejercicios más que sobre clases laterales y subgrupos, son sobre el uso de Sage como herramienta experimental.  Están diseñados para ayudarle a ser más eficiente y más expresivo, a la hora de escribir comandos en Sage.  Tendremos muchas oportunidades de trabajar con clases laterales y subgrupos en los capítulos que vienen.  Estos ejercicios no son tan guiados y su dificultad va en aumento.  Están diseñados para explorar, o confirmar, resultados presentados en este o anteriores capítulos.</p>

		<p><alert>Importante</alert>: Debiese contestar cada uno de los últimos tres problemas con una sola línea (complicada) de Sage cuyo resultado sea <c>True</c>.  Una <q>sola línea</q> quiere decir que tendrá varios comandos de Sage usados juntos de formas complejas.  No quiere decir varios comandos Sage separados por punto y coma, tipeados en una sola línea.  Asegúrese de incluir algunos pasos intermedios usados en construir su solución, pero usando rangos de números más pequeños para no abrumar al lector con demasiado para mirar.  Esto le ayudará a usted y al corrector de su trabajo para tener confianza en que la versión final es correcta.</p>

		<p>Cuando verifique la divisibilidad de enteros, recuerde que <c>range()</c> produce enteros comunes, cuya funcionalidad es básica.  El comando <c>srange()</c> produce enteros Sage, que tienen más capacidades.  (Vea el último ejercicio como ejemplo.)  Y recuerde que una lista es una forma compacta de examinar muchas posibilidades a la vez.</p>
	</introduction>


	<exercise number="1">
		<statement>
			<p>Use <c>.subgroups()</c> para encontrar un ejemplo de un grupo <m>G</m> y un entero  <m>m</m>, tal que  (a) <m>m</m> divide el orden de  <m>G</m>, y (b) <m>G</m> no tiene subgrupo de orden  <m>m</m>.  (No use el grupo  <m>A_4</m> como <m>G</m>, pues ese está en el texto.)  Escriba una sola línea de código Sage que contenga toda la lógica necesaria para producir  <m>m</m> como respuesta.  (Puede darle un nombre simple a su grupo en una línea previa y luego referirse a él por ese nombre.)  A continuación un ejemplo muy simple que le puede ayudar a estructurar su respuesta.</p>

			<sage>
				<input>
				a = 5
				b = 10
				c = 6
				d = 13
				a.divides(b)
				</input>
				<output>True</output>
			</sage>

			<sage>
				<input>not (b in [c,d])</input>
				<output>True</output>
			</sage>

			<sage>
				<input>a.divides(b) and not (b in [c,d])</input>
				<output>True</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="2">
		<statement>
			<p>Ejemplifique el Pequeño Teorema de Fermat (en cualquiera de sus variantes) usando el número compuesto <m>391=17\cdot 23</m> como elección de base (ya sea <m>a</m> o <m>b</m>), y para <m>p</m> recorriendo todos los valores primos entre  <m>100</m> y <m>1000</m>.</p>

			<p>Construya paulatinamente una solución <mdash/> haga una lista de potencias (empezando por unos pocos primos), luego haga una lista de potencias reducidas en la aritmética modular, luego una lista de comparaciones con el valor predicho, luego verifique todos estos valores lógicos resultantes de la comparación.  Esta es una estrategia útil en muchos problemas similares.  Finalmente podrá escribir una sola línea que realice la verificación completa y devuelva <c>True</c>.  A continuación hay algunas sugerencias de funciones útiles.</p>

			<sage>
				<input>
				a = 20
				b = 6
				a.mod(b)
				</input>
				<output>2</output>
			</sage>

			<sage>
				<input>prime_range(50, 100)</input>
				<output>[53, 59, 61, 67, 71, 73, 79, 83, 89, 97]</output>
			</sage>

			<sage>
				<input>all([True, True, True, True])</input>
				<output>True</output>
			</sage>

			<sage>
				<input>all([True, True, False, True])</input>
				<output>False</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="3">
		<statement>
			<p>Verifique que el grupo de unidades  mód <m>n</m> tiene orden  <m>n-1</m> cuando  <m>n</m> es primo, nuevamente para todos los primos entre <m>100</m> y <m>1000</m>.  Como antes, su resultado debe ser simplemente  <c>True</c>, una única vez, indicando que la proposición respecto al orden es verdadera para todos los primos examinados.  Como antes, construya su solución paso a paso, y con conjuntos menores de primos en el comienzo.  Exprese su respuesta como una sola línea de código  Sage.</p>
		</statement>
		
	</exercise>

	<exercise number="4">
		<statement>
			<p>Verifique el Teorema de  Euler para todos los valores <m>0\lt n\lt 100</m> y para <m>1\leq a \leq n</m>.  Esto requerirá bucles <c>for</c> anidados con un condicional.  Nuevamente, a continuación un pequeño ejemplo que puede ser útil para construir su línea única de código Sage.  Note el uso de <c>srange()</c> en este ejemplo.</p>

			<sage>
				<input>[a/b for a in srange(9) for b in srange(1,a) if gcd(a,b)==1]</input>
				<output>
				[2, 3, 3/2, 4, 4/3, 5, 5/2, 5/3, 5/4, 6, 6/5,
				 7, 7/2, 7/3, 7/4, 7/5, 7/6, 8, 8/3, 8/5, 8/7]
				</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="5">
		<statement>
			<p>El grupo simétrico en  <m>7</m> símbolos, <m>S_7</m>, tiene <m>7! = 5040</m> elementos.  Considere las siguientes preguntas sin utilizar Sage, basado en lo que sabemos sobre los órdenes de los elementos en grupos de permutaciones (Ejercicio<nbsp/><xref ref="exercise-permute-order-product-cycles"/>).<ul>
				<li><p>¿Cuál es el mayor orden posible?</p></li>
				<li><p>¿Cuántos elementos hay de orden <m>10</m>?</p></li>
				<li><p>¿Cuántos elementos hay de orden <m>1</m>?</p></li>
				<li><p>¿Cuántos elementos hay de orden <m>2</m>?</p></li>
				<li><p>¿Cuál es el menor entero positivo para el que no hay elemento de ese orden?</p></li>
			</ul></p>

			<p>Estas preguntas resultan más fáciles si sabe usar los coeficientes binomiales para contar en situaciones similarmenate complejas.  En cualquier caso, reflexione seriamente sobre cada una de esta preguntas (y quizás alguna otra que se le ocurra) antes de lanzarse con Sage.</p>

			<p>Ahora, calcule cuántos elementos hay de cada orden usando el método <c>.order()</c>, e incluya esto en una lista exhaustiva que contenga el número de elementos de cada orden.  Puede verificar su trabajo (o el de Sage) usando el comando  <c>sum()</c>  para sumar esta lista y ojalá obteniendo <m>5040</m>.</p>

			<p>Comente el proceso de primero estudiar estas preguntas sin ayuda computacional, y luego nuevamente con Sage.  ¿Para qué valores de <m>n</m> cree que Sage sería demasiado lento y su mente más rápida?</p>
		</statement>
		
	</exercise>

</exercises>
