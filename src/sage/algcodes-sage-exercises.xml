<?xml version="1.0"?>
<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->
<!--                                               -->
<!-- This file is automatically generated from the -->
<!-- private solution manual.  Minor contributed   -->
<!-- edits can be made against this file for       -->
<!-- the purpose of a pull request.                -->
<exercises xml:id="algcodes-sage-exercises">
    <title>Ejercicios en Sage</title>

    <exercise number="1">
        <statement>
            <p>Construya el código (binario) Golay con el constructor <c>codes.GolayCode()</c>.  Lea la documentación para asegurarse de construir la versión binaria (y no la ternaria), y no construya la versión extendida (que es el default).</p>

            <ol>
                <li><p>Use métodos Sage para calcular el largo, la dimensión y la distancia mínima del código.</p></li>
                <li><p>¿Cuántos errores puede detectar este código?  ¿Cuántos puede corregir?</p></li>
                <li><p>Encuentre una palabra distinta de cero en el código e introduzca tres errores sumando un vector con tres 1's (de su elección) para crear un mensaje recibido.  Muestre que el mensaje se decodifica correctamente.</p></li>
                <li><p>Recicle sus elecciones de la parte anterior, pero ahora agregue un error adicional.  ¿Se decodifica correctamente el mensaje recibido?</p></li>
            </ol>
        </statement>
        
    </exercise>

    <exercise number="2">
        <statement>
            <p>Una técnica que permita mejorar las características de un código es agregar un bit de paridad general, tal como el bit de paridad del código <acro>ASCII</acro> descrito en el Ejemplo<nbsp/><xref ref="example-algcodes-even-parity"/>.  Tales códigos se conocen como versiones <term>extendidas</term> del código original.</p>

            <ol>
                <li><p>Construya el código de Golay binario y obtenga la matriz evrificadora.  Use comandos Sage para extender esta matriz creando una nueva matriz de paridad que considere un bit de paridad global adicional.  los métodos <c>.augment()</c> y <c>.stack()</c> para matrices le pueden resultar útiles, así como los constructores <c>zero_vector()</c> y <c>ones_matrix()</c> (recordando que especificamos las entradas binarias como pertenecientes al cuerpo <c>GF(2)</c>.)</p>

                <p>Cree el código extendido entregando la matriz de paridad aumentada al constructor <c>codes.from_parity_check_matrix()</c> y calcule la longitud, dimension y distancia mínima del código extendido.</p></li>

                <li><p>¿En qué sentido son mejores las características de este nuevo código? ¿A qué costo?</p></li>

                <li><p>Ahora cree el código de Golay binario extendido con <c>codes.GolayCode()</c> y la opción apropiada para obtener la versión extendida.  Con algo de suerte, las listas ordenadas de sus palabras y las del código implementado en Sage, serán las mismas.  Si no, el método <c>.is_permutation_equivalent()</c> debiera retornar <c>True</c> indicando que su código y el de Sage son simplemente reordenamientos, el uno del otro.</p></li>
            </ol>
        </statement>
        
    </exercise>

    <exercise number="3">
        <statement>
            <!--
            <p><em>Note:</em> This problem is on holiday (as of Sage 6.7), while some buggy Sage code for the minimum distance of a Hamming code gets sorted out.  The <c>r = 2</c> case produces an error message and for <c>r &gt; 5</c> the computation of the minimum distance has become intolerably slow.  So it is a bit harder to make a reasonable conjecture from just <m>3</m> cases.</p>
            -->
            <p>El dual de un código de bloque <m>(n,k)</m> está formado por el conjunto de los vectores bianrios ortogonales a todos los vectores del código original.  El Ejercicio<nbsp/><xref ref="exercise-algcodes-dual-code"/> describe esta construcción y pregunta por algunas de sus propiedades.</p>

            <p>Se puede obtener el dual de un código en Sage con el método <c>.dual_code()</c>.  Construya los códigos de Hamming binarios, y sus duales, con el parámetro <c>r</c> variando desde <c>2</c> hasta <c>5</c>.  Construya una tabla con seis columnas (posiblemente usando la función <c>html.table()</c>) que liste <m>r</m>, el largo del código, la dimensión del código original, la de su dual, la distancia mínima del código y la de su dual.</p>

            <p>Conjeture fórmulas para la dimensión y distancia mínima del dual de un código de Hamming en términos del parámetro <m>r</m>.</p>
        </statement>
        
    </exercise>

    <exercise number="4">
        <statement>
            <p>Un código con distancia mínima <m>d</m> se llama <term>perfecto</term> si todo vector posible está a distancia menor o igual a <m>(d-1)/2</m> de alguna palabra del código.  Si expandimos nuestra idea de geometría para incluir la noción de distancia de Hamming como la métrica, entonces podemos hablar de una esfera de radio <m>r</m> en torno a un vector o palabra.  Para un código de longitud <m>n</m>, una esfera de este tipo contiene <me>1 + {n\choose 1} + {n\choose 2} + \cdots + {n\choose r}</me> vectores en su interior.  Para un código perfecto, las esferas de radio <m>(d-1)/2</m> centradas en las palabras del código particionan exactamente el espacio de todos los vectores posibles.  (Esto es lo que establece una relación entre la teoría de códigos y los problemas de empaquetamiento de esferas.)</p>

            <p>Una consecuencia de que un código de dimensión <m>k</m> sea perfecto es que <me>2^k\left({n\choose 0} + {n\choose 1} + {n\choose 2} + \cdots + {n\choose \frac{d-1}{2}}\right) = 2^n</me>  Recíprocamente, si un código tiene distancia mínima <m>d</m> y cumple la condición anterior, entonces el código es perfecto.</p>

            <p>Escriba una función en Sage, llamada <c>is_perfect()</c> que tome un código lineal como entrada y retorne <c>True</c> o <c>False</c> según si el código es o no perfecto.  Demuestre su función verificando que el código de Golay binario es perfecto, y use un bucle para verificar que los códigos de Hamming binarios son perfectos para longitudes menores a <m>32</m>.</p>
        </statement>
        
    </exercise>

    <!-- Potential exercise 5: probabilty and Shannon bound -->
</exercises>
