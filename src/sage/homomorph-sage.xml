<?xml version="1.0" encoding="UTF-8" ?>

<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->

<section xml:id="homomorph-sage">
    <title>Sage</title>

    <introduction>
        <p>Sage es capaz de crear homomorfismos (y por ende, isomorfismos y automorfismos) entre grupos finitos de permutaciones.  Hay pocos comandos disponibles para manipular estas funciones, pero aún así podremos ilustrar muchas de las ideas de este capítulo.</p>
    </introduction>

    <subsection>
        <title>Homomorfismos</title>

        <p>La principal forma de crear un homomorfismo es especificando las imágenes para el conjunto de generadores del dominio.  Considere grupos cíclicos de órdenes <m>12</m> y <m>20</m>:<md>
          <mrow>G &amp;= \{a^i\vert a^{12}=e\} &amp; H &amp;= \{x^i\vert x^{20}=e\}</mrow>
        </md> y defina un homomorfismo simplemente especificando la imagen para un generador de <m>G</m>, y extendiendo la función al resto del grupo via la propiedad de preservación de la operación de un homomorfismo. <md>
          <mrow>\phi: G\rightarrow H, &amp;\quad\phi(a)=x^5</mrow>
          <mrow>\Rightarrow           &amp;\quad\phi(a^i) = \phi(a)^i = (x^5)^i = x ^{5i}</mrow>
        </md>  El constructor <c>PermutationGroupMorphism</c> requiere los dos grupos, luego una lista de imágenes para cada generador (¡en orden!), y entonces creará el homomorfismo.  Note que podemos usar el resultado como una función.  En el ejemplo abajo, primero verificamos que <c>C12</c> tiene un único generador (ninguna novedad), el cuál enviamos a un elemento particular de orden  <m>4</m> en el codominio.  Sage entonces construye el único homomorfismo consistente con este requisito.</p>

        <sage>
        <input>
        C12 = CyclicPermutationGroup(12)
        C20 = CyclicPermutationGroup(20)
        domain_gens = C12.gens()
        [g.order() for g in domain_gens]
        </input>
        <output>
        [12]
        </output>
        </sage>

        <sage>
        <input>
        x = C20.gen(0)
        y = x^5
        y.order()
        </input>
        <output>
        4
        </output>
        </sage>

        <sage>
        <input>
        phi = PermutationGroupMorphism(C12, C20, [y])
        phi
        </input>
        <output>
        Permutation group morphism:
          From: Cyclic group of order 12 as a permutation group
          To:   Cyclic group of order 20 as a permutation group
          Defn: [(1,2,3,4,5,6,7,8,9,10,11,12)] ->
                [(1,6,11,16)(2,7,12,17)(3,8,13,18)(4,9,14,19)(5,10,15,20)]
        </output>
        </sage>

        <sage>
        <input>
        a = C12("(1,6,11,4,9,2,7,12,5,10,3,8)")
        phi(a)
        </input>
        <output>
        (1,6,11,16)(2,7,12,17)(3,8,13,18)(4,9,14,19)(5,10,15,20)
        </output>
        </sage>

        <sage>
        <input>
        b = C12("(1,3,5,7,9,11)(2,4,6,8,10,12)")
        phi(b)
        </input>
        <output>
        (1,11)(2,12)(3,13)(4,14)(5,15)(6,16)(7,17)(8,18)(9,19)(10,20)
        </output>
        </sage>

        <sage>
        <input>
        c = C12("(1,9,5)(2,10,6)(3,11,7)(4,12,8)")
        phi(c)
        </input>
        <output>
        ()
        </output>
        </sage>

        <p>Note que el elemento <c>c</c> debe por lo tanto estar en el núcleo de <c>phi</c>.</p>

        <p>Podemos calcular el subgrupo del dominio que es el núcleo, y en este caso un grupo cíclico de orden  <m>3</m> al interior del grupo cíclico de orden  <m>12</m>.  Podemos calcular la imagen de  <em>cualquier</em> subgrupo, pero acá construiremos la imagen homomorfa completa entregándole el dominio completo al método <c>.image()</c>.  La imagen es un subgrupo cíclico de orden  <m>4</m> dentro del grupo cíclico de orden  <m>20</m>.  Además verificaremos el Primer Teorema de Isomorfía.</p>

        <sage>
        <input>
        K = phi.kernel(); K
        </input>
        <output>
        Subgroup of (Cyclic group of order 12 as a permutation group)
        generated by [(1,5,9)(2,6,10)(3,7,11)(4,8,12)]
        </output>
        </sage>

        <sage>
        <input>
        Im = phi.image(C12); Im
        </input>
        <output>
        Subgroup of (Cyclic group of order 20 as a permutation group)
        generated by [(1,6,11,16)(2,7,12,17)(3,8,13,18)(4,9,14,19)(5,10,15,20)]
        </output>
        </sage>

        <sage>
        <input>
        Im.is_isomorphic(C12.quotient(K))
        </input>
        <output>
        True
        </output>
        </sage>

        <p>Ahora un ejemplo ligeramente más complicado.  El grupo dihedral <m>D_{20}</m> es el grupo de simetrías de un polígono regular de 20 lados.  Dentro de este grupo hay un subgrupo que es isomorfo al grupo de simetrías de un pentágono regular.  ¿Es una sorpresa o es obvio?  Acá hay una forma de precisar la afirmación de que <q><m>D_{20}</m> contiene una copia de <m>D_{5}</m>.</q></p>

        <p>Construimos el dominio y encontramos sus generadores, así sabemos cuántas imágenes proveer en la definición del homomorfismo.  Después construimos el codominio, en el que construiremos imágenes.  Nuestra elección acá es enviar una reflexión en una reflexión, y una rotación en una rotación.  Pero las rotaciones deben ambas tener orden <m>5</m>, y ambas ser rotaciones en <m>72</m> grados.</p>

        <sage>
        <input>
        G = DihedralGroup(5)
        H = DihedralGroup(20)
        G.gens()
        </input>
        <output>
        [(1,2,3,4,5), (1,5)(2,4)]
        </output>
        </sage>

        <sage>
        <input>
        H.gens()
        </input>
        <output>
        [(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20),
         (1,20)(2,19)(3,18)(4,17)(5,16)(6,15)(7,14)(8,13)(9,12)(10,11)]
        </output>
        </sage>

        <sage>
        <input>
        x = H.gen(0)^4
        y = H.gen(1)
        rho = PermutationGroupMorphism(G, H, [x, y])
        rho.kernel()
        </input>
        <output>
        Subgroup of (Dihedral group of order 10 as a permutation group)
        generated by [()]
        </output>
        </sage>

        <p>Como el núcleo es trivial, <c>rho</c> es una función 1-1 (ver el Ejercicio<nbsp /><xref ref="exercise-trivial-kernel" />).  Pero más importante, por el Primer Teorema de Isomorfía, <c>G</c> es isomorfo a la imagen del homomorfismo.  Calcularemos la imagen para verificar la afirmación.</p>

        <sage>
        <input>
        Im = rho.image(G); Im
        </input>
        <output>
        Subgroup of (Dihedral group of order 40 as a permutation group)
        generated by
        [(1,5,9,13,17)(2,6,10,14,18)(3,7,11,15,19)(4,8,12,16,20),
        (1,20)(2,19)(3,18)(4,17)(5,16)(6,15)(7,14)(8,13)(9,12)(10,11)]
        </output>
        </sage>

        <sage>
        <input>
        Im.is_subgroup(H)
        </input>
        <output>
        True
        </output>
        </sage>

        <sage>
        <input>
        Im.is_isomorphic(G)
        </input>
        <output>
        True
        </output>
        </sage>

        <p>Simplemente dando una lista de imágenes para los generadores del dominio no es una garantía de que la función pueda extenderse a un homomorfismo.  Para empezar, el orden de cada imagen debe dividir al orden de la preimagen correspondiente.  (¿Puede demostrar esto?)  Similarmente, si el dominio es abeliano, entonces la imagen debe también ser abeliana, así en este caso las imágenes no debiesen generar un subgrupo no abeliano.  Por ejemplo,  no hay homomorfismos de un grupo cíclico de orden  <m>7</m> a un grupo cíclico de orden <m>4</m> (salvo la función trivial que lleva a todos los elementos a la identidad).  Para ver esto, considere los posibles órdenes del núcleo, y de las dos posibilidades, vea que una es imposible y que la otra se realiza con el homomorfismo trivial.  Desafortunadamente, Sage actúa como si no hubiera nada malo en crear un homomorfismo entre estos dos grupos, pero lo que Sage crea es inútil y produce errores si trata de usarlo.</p>

        <sage>
        <input>
        G = CyclicPermutationGroup(7)
        H = CyclicPermutationGroup(4)
        tau = PermutationGroupMorphism_im_gens(G, H, H.gens())
        tau
        </input>
        <output>
        Permutation group morphism:
          From: Cyclic group of order 7 as a permutation group
          To:   Cyclic group of order 4 as a permutation group
          Defn: [(1,2,3,4,5,6,7)] -> [(1,2,3,4)]
        </output>
        </sage>

        <sage>
        <input>
        tau.kernel()
        </input>
        <output>
        Traceback (most recent call last):
        ...
        RuntimeError: Gap produced error output
        ...
        </output>
        </sage>

        <p>En lugar de crear homomorfismos por nosotros mismos, en ciertas situaciones Sage sabe de la existencia de homomorfismos naturales y los creará para nosotros.  Un caso de estos es la construcción del producto directo.  Dado un grupo  <c>G</c>, el método  <c>.direct_product(H)</c> creará el producto directo <m>G\times H</m>.  (Este no es el mismo comando que la función  <c>direct_product_permgroups()</c> de antes.)  Este comando no solo crea el producto directo, sino que además construye <em>cuatro</em> homomorfismos, uno con dominio <m>G</m>, uno con dominio <m>H</m> y dos con dominio <m>G\times H</m>.  Así la salida consiste de cinco objetos, el primero de los cuales es el grupo en sí, y los restantes son homomorfismos.  Mostraremos un ejemplo acá y dejaremos una investigación más exhaustiva para los ejercicios.</p>

        <sage>
        <input>
        G = CyclicPermutationGroup(3)
        H = DihedralGroup(4)
        results = G.direct_product(H)
        results[0]
        </input>
        <output>
        Permutation Group with generators [(4,5,6,7), (4,7)(5,6), (1,2,3)]
        </output>
        </sage>

        <sage>
        <input>
        results[1]
        </input>
        <output>
        Permutation group morphism:
          From: Cyclic group of order 3 as a permutation group
          To:   Permutation Group with generators
                [(4,5,6,7), (4,7)(5,6), (1,2,3)]
          Defn: Embedding( Group( [ (1,2,3), (4,5,6,7), (4,7)(5,6) ] ), 1 )
        </output>
        </sage>

        <sage>
        <input>
        results[2]
        </input>
        <output>
        Permutation group morphism:
          From: Dihedral group of order 8 as a permutation group
          To:   Permutation Group with generators
                [(4,5,6,7), (4,7)(5,6), (1,2,3)]
          Defn: Embedding( Group( [ (1,2,3), (4,5,6,7), (4,7)(5,6) ] ), 2 )
        </output>
        </sage>

        <sage>
        <input>
        results[3]
        </input>
        <output>
        Permutation group morphism:
          From: Permutation Group with generators
                [(4,5,6,7), (4,7)(5,6), (1,2,3)]
          To:   Cyclic group of order 3 as a permutation group
          Defn: Projection( Group( [ (1,2,3), (4,5,6,7), (4,7)(5,6) ] ), 1 )
        </output>
        </sage>


        <sage>
        <input>
        results[4]
        </input>
        <output>
        Permutation group morphism:
          From: Permutation Group with generators
                [(4,5,6,7), (4,7)(5,6), (1,2,3)]
          To:   Dihedral group of order 8 as a permutation group
          Defn: Projection( Group( [ (1,2,3), (4,5,6,7), (4,7)(5,6) ] ), 2 )
        </output>
        </sage>

    </subsection>

</section>


