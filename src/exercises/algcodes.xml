<?xml version="1.0"?>
<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 1997-2014  Thomas W. Judson     -->
<!-- See the file COPYING for copying conditions.  -->
<!--                                               -->
<!-- This file is automatically generated from the -->
<!-- private solution manual.  Minor contributed   -->
<!-- edits can be made against this file for       -->
<!-- the purpose of a pull request.                -->
<exercises xml:id="exercises-algcodes">
	<title>Ejercicios</title>

	<exercise number="1">
		<statement>
			<p>¿Por qué no es aceptable el siguiente sistema de codificación?</p>

			<sidebyside width="100%"> <!-- check centering -->
				<tabular halign="center" top="medium">
		        	<row bottom="medium">
		        		<cell>Información</cell><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell>7</cell><cell>8</cell>
		        	</row>
					<row bottom="medium">
						<cell>Palabra del Código</cell><cell>000</cell><cell>001</cell><cell>010</cell><cell>011</cell><cell>101</cell><cell>110</cell><cell>111</cell><cell>000</cell><cell>001</cell>
					</row>
			   </tabular>
			</sidebyside>
			
		</statement>
		
	</exercise>

	<exercise number="2">
		<statement>
			<p>Sin realizar ninguna suma, explique por qué el siguiente conjunto de 4-tuplas en <m>{\mathbb Z}_2^4</m> no puede ser un código de grupo. 
				<me>(0110) \quad (1001) \quad (1010) \quad (1100)</me></p>
		</statement>
		<hint>
			<p>No puede ser un código de gruops pues <m>(0000) \notin C</m>.</p>
		</hint>
		
	</exercise>

	<exercise number="3">
		<statement>
			<p>Calcule las distancias de Hamming entre las siguientes pares de <m>n</m>-tuplas.
				<ol cols="2">

					<li><p><m>(011010), (011100)</m></p></li>

					<li><p><m>(11110101), (01010100)</m></p></li>

					<li><p><m>(00110), (01111)</m></p></li>

					<li><p><m>(1001), (0111)</m></p></li>

				</ol></p>
		</statement>
		<hint>
			<p>(a) 2; (c) 2.</p>
		</hint>
		
	</exercise>

	<exercise number="4">
		<statement>
			<p>Calcule los pesos de las siguientes <m>n</m>-tuplas.
				<ol cols="2">

					<li><p><m>(011010)</m></p></li>

					<li><p><m>(11110101)</m></p></li>

					<li><p><m>(01111)</m></p></li>

					<li><p><m>(1011)</m></p></li>

				</ol></p>
		</statement>
		<hint>
			<p>(a) 3; (c) 4.</p>
		</hint>
		
	</exercise>

	<exercise number="5">
		<statement>
			<p>Si un código lineal <m>C</m> tiene peso mínimo 7, ¿cuáles son las capacidades de detección y corrección de errores de  <m>C</m>?</p>
		</statement>
		
	</exercise>

	<exercise number="6">
		<statement>
			<p>Para cada uno de los siguientes códigos, ¿cuál es la distancias mínima del código? ¿Cuál es la mejor situación que podemos esperar en relación a detección y corrección de errores? 
				<ol>
				 
					<li><p><m>(011010) \; (011100) \; (110111) \; (110000)</m></p></li>
					 
					<li><p><m>(011100) \; (011011) \; (111011) \; (100011)</m> \; <m>(000000) \; (010101) \; (110100) \; (110011)</m></p></li>
					 
					<li><p><m>(000000) \; (011100) \; (110101) \; (110001)</m></p></li>
					 
					<li><p><m>(0110110) \; (0111100) \; (1110000) \; (1111111)</m> \; <m>(1001001) \; (1000011) \; (0001111) \; (0000000)</m></p></li>
				 
				</ol></p>
		</statement>
		<hint>
			<p>(a) <m>d_{\min} = 2</m>; (c) <m>d_{\min} = 1</m>.</p>
		</hint>
		
	</exercise>

	<exercise number="7">
		<statement>
			<p>Calcule el espacio nulo de cada una de las siguientes matrices.  ¿Qué tipo de códigos de bloque <m>(n,k)</m> son los espacios nulos? ¿Puede encontrar una matriz (no necesariamente una matriz generadora estándar) que genere cada código? ¿Son únicas sus matrices generadoras?
				<ol cols="2">

					<li><p><me>\begin{pmatrix}
					0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
					1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
					1 &amp; 0 &amp; 0 &amp; 1 &amp; 0
					\end{pmatrix}</me></p></li>

					<li><p><me>\begin{pmatrix}
					1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
					1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
					0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
					1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
					\end{pmatrix}</me></p></li>

					<li><p><me>\begin{pmatrix}
					1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
					0 &amp; 1 &amp; 0 &amp; 1 &amp; 1
					\end{pmatrix}</me></p></li>

					<li><p><me>\begin{pmatrix}
					0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
					0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
					1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
					0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1
					\end{pmatrix}</me></p></li>

				</ol></p>
		</statement>
		<hint>
			<p><ol>
			 
				<li><p><m>(00000), (00101), (10011), (10110)</m>
					<me>G = 
					\begin{pmatrix}
					0 &amp; 1 \\
					0 &amp; 0 \\
					1 &amp; 0 \\
					0 &amp; 1 \\
					1 &amp; 1
					\end{pmatrix}</me></p></li>
				 
				<li><p><m>(000000), (010111), (101101), (111010)</m>
					<me>G = 
					\begin{pmatrix}
					1 &amp; 0 \\
					0 &amp; 1 \\
					1 &amp; 0 \\
					1 &amp; 1 \\ 
					0 &amp; 1 \\
					1 &amp; 1
					\end{pmatrix}</me></p></li>
			 
			</ol></p>
		</hint>
		
	</exercise>

	<exercise number="8">
		<statement>
			<p>Construya un código de bloque <m>(5,2)</m>. Discuta las capacidades de detección y corrección de errores de su código.</p>
		</statement>
		
	</exercise>

	<exercise number="9">
		<statement>
			<p>Sea <m>C</m> el código obtenido como espacio nulo de la matriz
				<me>H =
				\begin{pmatrix}
				0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
				1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
				0 &amp; 0 &amp; 1 &amp; 1 &amp; 1
				\end{pmatrix}.</me>
			Decodifique el mensaje
				<me>01111 \quad 10101 \quad 01110 \quad 00011</me>
			si es posible.</p>
		</statement>
		<hint>
			<p>Multiples errores ocurren en una de las palabras recibidas.</p>
		</hint>
		
	</exercise>

	<exercise number="10">
		<statement>
			<p>Supongamos que se transmite un mensaje binario de 1000 bits, que la probabilidad de error en un bit es <m>p</m> y que los errores que puedan ocurrir en bits diferentes son independientes entre ellos. Si <m>p = 0.01</m>, ¿Cuál es la probabilidad de que ocurra más de un error? ¿Cuál es la probabilidad de que ocurran exactamente dos errores?  Repita el problema para <m>p = 0.0001</m>.</p>
		</statement>
		
	</exercise>

	<exercise number="11" xml:id="exercise-algcodes-check-matrices">
		<statement>
			<p>¿Qué matrices son matrices verificadoras canónicas? Para aquella matrices que sean matrices verificadoras canónicas, ¿cuáles son las correspondientes matrices generadoras estándar? ¿Cuáles son las capacidades de detección y corrección de errores de cada una de  estas matrices?
				<ol cols="2">

					<li><p><me>\begin{pmatrix}
					1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
					0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
					0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
					1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
					\end{pmatrix}</me></p></li>

					<li><p><me>\begin{pmatrix}
					0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
					1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
					0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
					1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
					\end{pmatrix}</me></p></li>

					<li><p><me>\begin{pmatrix}
					1 &amp; 1 &amp; 1 &amp; 0 \\
					1 &amp; 0 &amp; 0 &amp; 1
					\end{pmatrix}</me></p></li>

					<li><p><me>\begin{pmatrix}
					0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
					0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
					1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
					0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
					\end{pmatrix}</me></p></li>

				</ol></p>
		</statement>
		<hint>
			<p>(a) Es matriz verificadora canónica con matriz generadora estándar
					<me>G = 
					\begin{pmatrix}
					1 \\ 1 \\ 0 \\ 0 \\ 1
					\end{pmatrix}.</me></p>

			<p>(c) Es matriz verificadora canónica con matriz generadora estándar
					<me>G = 
					\begin{pmatrix}
					1 &amp; 0 \\
					0 &amp; 1 \\
					1 &amp; 1 \\
					1 &amp; 0
					\end{pmatrix}.</me></p>
		</hint>
		
	</exercise>

	<exercise number="12">
		<statement>
			<p>Liste todos los posible síndromes para los códigos generados por cada una de las matrices del Ejercicio<nbsp/><xref ref="exercise-algcodes-check-matrices"/>.</p>
		</statement>
		<hint>
			<p>(a) Ocurren todos los posibles síndromes.</p>
		</hint>
		
	</exercise>

	<exercise number="13">
		<statement>
			<p>Sea
				<me>H =
				\begin{pmatrix}
				0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
				0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
				1 &amp; 0 &amp; 1 &amp; 0 &amp; 1
				\end{pmatrix}.</me>
			Calcule el síndrome causado por cada uno de los siguientes errores de transmisión. 
				<ol>
				 
					<li><p>Un error en el primer bit.</p></li>
					 
					<li><p>Un error en el tercer bit.</p></li>
					 
					<li><p>Un error en el último bit.</p></li>
					 
					<li><p>Errores en el tercer y cuarto bits.</p></li>
				 
				</ol></p>
		</statement>
		
	</exercise>

	<exercise number="14">
		<statement>
			<p>Sea <m>C</m> el código de grupo en <m>{\mathbb Z}_2^3</m> definido por las palabras <m>(000)</m> and <m>(111)</m>. Calcule las clases laterales de <m>H</m> en <m>{\mathbb Z}_2^3</m>. ¿Por qué no es necesario especificar si se trata de clases laterales derechas o izquierdas? Entregue el error singular de transmisión, si lo hay, que corresponda con cada clase lateral.</p>
		</statement>
		
	</exercise>

	<exercise number="15">
		<statement>
		<p>Para cada una de las siguientes matrices, encuentre las clases laterales para el código <m>C</m> correspondiente. Entregue una tabla de decodificación para cada código si es posible.
			<ol cols="2">

				<li><p><me>\begin{pmatrix}
				0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
				1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
				1 &amp; 0 &amp; 0 &amp; 1 &amp; 0
				\end{pmatrix}</me></p></li>

				<li><p><me>\begin{pmatrix}
				0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
				1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
				0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
				1 &amp; 1 &amp; 0 &amp; 0 &amp; 1
				\end{pmatrix}</me></p></li>

				<li><p><me>\begin{pmatrix}
				1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
				0 &amp; 1 &amp; 0 &amp; 1 &amp; 1
				\end{pmatrix}</me></p></li>

				<li><p><me>\begin{pmatrix}
				1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
				1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
				1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
				1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0
				\end{pmatrix}</me></p></li>

			</ol></p>
		</statement>
		<hint>
			<p>(a) <m>C</m>, <m>(10000) + C</m>, <m>(01000) + C</m>, <m>(00100) + C</m>, <m>(00010) + C</m>, <m>(11000) + C</m>, <m>(01100) + C</m>, <m>(01010) + C</m>.  No hay tabla de decodificación para <m>C</m> pues este es solo un código detector de un error.</p>
		</hint>
		
	</exercise>

	<exercise number="16">
		<statement>
			<p>Sean <m>{\mathbf x}</m>, <m>{\mathbf y}</m>, y <m>{\mathbf z}</m>  <m>n</m>-tuplas binarias. Demuestre cada uno de los siguientes enunciados. 
				<ol>
				 
					<li><p><m>w({\mathbf x}) = d( {\mathbf x}, {\mathbf 0})</m></p></li>
					 
					<li><p><m>d( {\mathbf x}, {\mathbf y}) = d( {\mathbf x} + {\mathbf z}, {\mathbf y} + {\mathbf z} )</m></p></li>
					 
					<li><p><m>d({\mathbf x}, {\mathbf y}) = w({\mathbf x}- {\mathbf y})</m></p></li>
				 
				</ol></p>
		</statement>
		
	</exercise>

	<exercise number="17">
		<statement>
			<p>Una <term>métrica</term> en un conjunto <m>X</m> es una función <m>d: X \times X \rightarrow {\mathbb R}</m> que satisface las siguientes condiciones. 
				<ol>
		 
					<li><p><m>d( {\mathbf x}, {\mathbf y}) \geq 0</m> para todo <m>{\mathbf x}, {\mathbf y} \in X</m>;</p></li>
		 
					<li><p><m>d( {\mathbf x}, {\mathbf y}) = 0</m> si y solo si <m>{\mathbf x} = {\mathbf y}</m>;</p></li>
		 
					<li><p><m>d( {\mathbf x}, {\mathbf y})= d( {\mathbf y}, {\mathbf x})</m>;</p></li>
		 
					<li><p><m>d( {\mathbf x}, {\mathbf y}) \leq d( {\mathbf x}, {\mathbf z}) + d( {\mathbf z}, {\mathbf y})</m>.</p></li>
		 
				</ol>En otros palabras, una métrica es simplemente una generalización de la noción de distancia. Demuestre que la distancia de Hamming es una métrica en <m>{\mathbb Z}_2^n</m>. Decodificar un mensaje en realidad corresponde a decidir cuál es la palabra del código más cercana en términos de la distancia de Hamming.</p>
		</statement>
		
	</exercise>

	<exercise number="18">
		<statement>
			<p>Sea <m>C</m> un código lineal binario. Muestre que entre las <m>i</m>-ésimas coordenadas de la palabras en <m>C</m> hay puros ceros o exactamente la mitad son ceros.</p>
		</statement>
		
	</exercise>

	<exercise number="19">
		<statement>
			<p>Sea <m>C</m> un código lineal binario. Muestre que ya sea todas las palabras tienen peso par o exactamente la mitad de ellas tienen peso par.</p>
		</statement>
		<hint>
			<p>Sea <m>{\mathbf x} \in C</m> una palabra de peso impar y defina una función y defina una función del conjunto de todas las palabras de peso impar al conjunto de las palabras de peso par como <m>{\mathbf y} \mapsto {\mathbf x} + {\mathbf y}</m>. Muestre que esta función es una biyección.</p>
		</hint>
		
	</exercise>

	<exercise number="20">
		<statement>
			<p>Muestre que las palabras de peso par en un código lineal binario <m>C</m> también forman un código lineal.</p>
		</statement>
		
	</exercise>

	<exercise number="21">
		<statement>
			<p>Si hemos de usar un código lineal corrector de errores para transmitir los 128 caracteres <acro>ASCII</acro>, ¿qué tamaño de matriz debe usarse? ¿Qué tamaño de matriz debe usarse para transmitir el conjunto <acro>ASCII</acro> extendido de 256 caracteres?  ¿Y si solo requerimos detección de errores en ambos casos?</p>
		</statement>
		
	</exercise>

	<exercise number="22">
		<statement>
			<p>Encuentre la matriz verificadora canónica que da el código de verificación de paridad con tres posiciones de información. ¿Cuál es la matriz para siete posiciones de información?  ¿Cuáles son las matrices generadoras estándar correspondientes?</p>
		</statement>
		
	</exercise>

	<exercise number="23">
		<statement>
			<p>¿Cuántas posiciones de verificación se necesitan para un código de corrección de un error con 20 posiciones de información? ¿Con 32 posiciones de información?</p>
		</statement>
		<hint>
			<p>Para 20 posiciones de información, se requieren al menor 6 bits de verificación para permitir un código de corrección de un error.</p>
		</hint>
		
	</exercise>

	<exercise number="24">
		<statement>
			<p>Sea <m>{\mathbf e}_i</m> la  <m>n</m>-tupla binaria con un 1 en la <m>i</m>-ésima coordenada y <m>0</m> en las demás y supongamos que  <m>H \in {\mathbb M}_{m \times n}({\mathbb Z}_2)</m>. Muestre que <m>H{\mathbf e}_i</m> es la <m>i</m>-ésima columna de la matriz <m>H</m>. </p>
		</statement>
		
	</exercise>

	<exercise number="25" xml:id="exercise-algcodes-dual-code">
		<statement>
			<p>Sea <m>C</m> un código lineal <m>(n,k)</m>. Definamos el <term>código dual</term> o <term>código ortogonal</term> de <m>C</m> como 
				<me>C^\perp = \{ {\mathbf x} \in {\mathbb Z}_2^n :  {\mathbf x} \cdot {\mathbf y} = 0 \text{ para todo } {\mathbf y} \in C \}.</me>
				<ol>
 
					<li><p>Encuentre el código dual del código lineal <m>C</m> donde <m>C</m> está dado por la matriz 
						<me>\begin{pmatrix}
						1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
						0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
						1 &amp; 0 &amp; 0 &amp; 1 &amp; 0
						\end{pmatrix}.</me></p></li>
 
					<li><p>Muestre que <m>C^\perp</m> es un código lineal <m>(n, n-k)</m>.</p></li>
 
					<li><p>Encuentre las matrices verificadora canónica y generadora estándar de <m>C</m> y <m>C^\perp</m>. ¿Qué sucede en general? Demuestre su conjetura.</p></li>
 
				</ol></p>
		</statement>
		
	</exercise>

	<exercise number="26">
		<statement>
			<p>Sea <m>H</m> una matriz de <m>m \times n</m> sobre <m>{\mathbb Z}_2</m>, donde la <m>i</m>-ésima columna es el número <m>i</m> escrito en binario con <m>m</m> bits. El espacio nulo de una tal matriz se llama <term>código de Hamming</term>. 
				<ol>
 
					<li><p>Muestre que la matriz
						<me>H =
						\begin{pmatrix}
						0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
						0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
						1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0
						\end{pmatrix}</me>
				genera un código de Hamming. ¿Cuáles son las propiedades de corrección de errores de un código de Hamming?</p></li>
 
					<li><p>La columna correspondiente al síndrome también marca el bit donde ocurrió el error; es decir, la <m>i</m>-ésima columna de la matriz es <m>i</m> escrito como número binario, y el síndrome inmediatamente nos dice cuál es el bit erróneo. Si la palabra recibida es <m>(101011)</m>, Calcule el síndrome. ¿En qué bit ocurrió el error en este caso, y cuál era la palabra originalmente transmitida?</p></li>
 
					<li><p>Entregue un matriz binaria <m>H</m> para el código de Hamming con seis posiciones de informacióny cuatro de verificación. ¿Cuáles son la posiciones de verificación y cuáles son las de información? Codifique los mensajes <m>(101101)</m> y <m>(001001)</m>. Decodifique las palabras recibidas <m>(0010000101)</m> y <m>(0000101100)</m>.  ¿Cuáles son los posibles síndromes para este código?</p></li>
 
					<li><p>¿Cuál es el número de bits de verificación y el número de bits de información en un código de Hamming de bloque <m>(m,n)</m>? Encuentre tanto una cota superior como una cota inferior para el número de bits de información en términos del número de bits de verificación. Códigos de Hamming que tengan el máximo posible número de bits de información con <m>k</m> bits de verificación se llaman <term>perfectos</term>. Cada posible síndrome a excepción de <m>{\mathbf 0}</m> ocurre como una columna. Si el número de bits de información es menor al máximo, entonces el código se llama <term>recortado</term>. En este caso, dé un ejemplo donde algunos síndromes puedan representar errores múltiples.</p></li>
 
				</ol></p>
		</statement>
		
	</exercise>

</exercises>
